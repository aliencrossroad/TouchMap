<!DOCTYPE html>

<head>
    <link href="css/video-js.css" rel="stylesheet" />
    <link href="css/styles.css" rel="stylesheet" />

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>YTN GIS SYSTEM</title>

    <script type="text/javascript" src="js/jquery-3.4.1.min.js"></script>
    <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=d30b430fc168d024cbfef307b239c005&libraries=services"></script>
    <script type="text/javascript" src="js/video.js"></script>
    <script type="text/javascript" src="js/sketch.js"></script>

    <script>
        var initmaplevel = 13;
        var centerCoordinate = { // 지도의 중심좌표
            lan: 36.0,
            lon: 127.9259
        };

        var videoresolution = {
            width: "100%",
            height: "100%"
        };

        var polygons = [];
        var markers = [];
        var labels = [];
        var selectCenter;
        var mapInfo;
        var posX;
        var posY;

        $(document).ready(function() {

                var mapContainer = document.getElementById('map'), // 지도를 표시할 div 
                    mapOption = {
                        center: new kakao.maps.LatLng(centerCoordinate.lan, centerCoordinate.lon), // 지도의 중심좌표
                        level: initmaplevel // 지도의 확대 레벨
                    };

                // 지도를 생성합니다    
                var map = new kakao.maps.Map(mapContainer, mapOption);
                var mapTypeControl = new kakao.maps.MapTypeControl();
                map.addControl(mapTypeControl, kakao.maps.ControlPosition.TOPRIGHT);

                var player = videojs('videosource', {
                    "controls": false,
                    "autoplay": false,
                    "preload": "auto",
                    'html5': {
                        'nativeAudioTracks': false
                    }
                }, function onPlayerReady(e) {
                    this.src({
                        type: "application/x-mpegURL",
                        src: ""
                    });
                    this.tech_.off('dblclick');
                });

                var xhttp = new XMLHttpRequest();
                xhttp.onload = function() {
                    player.src({
                        type: "application/x-mpegURL",
                        src: xhttp.responseURL
                    });
                    player.play();
                };

                $('#home')
                    .on('touchstart click', function(e) {
                        e.preventDefault();

                        $('#videosource')[0].click();

                        // 현재 지도의 레벨을 얻어옵니다
                        var level = map.getLevel();

                        selectCenter = mapOption.center;

                        // 지도 레벨이 다르면 레벨 맞춰주고
                        if (level != initmaplevel) {
                            // 지도를 클릭된 폴리곤의 중앙 위치를 기준으로 확대합니다
                            map.setLevel(initmaplevel, {
                                animate: {
                                    duration: 350 //확대 애니메이션 시간
                                }
                            });
                        }
                        visibleMarker();

                        PenEnable(false);
                    });

                $('#pen')
                    .on('touchstart click', function(e) {
                        e.preventDefault();
                        if ($('#pen').attr("alt") == "touch") {
                            PenEnable(true);
                        } else {
                            PenEnable(false);
                        }
                    });

                $("#videosource").css("width", 0);
                $("#videosource").css("height", 0);
                $('#videosource')
                    .on('touchstart click', function(e) {
                        e.preventDefault();
                        $('#videosource').animate({
                            width: '0',
                            height: '0',
                            left: posX,
                            top: posY
                        }, 'slow', function() {
                            $("#videosource").css("display", "none");
                            $("#videosource")[0].player.pause();
                        })
                    });

                function PenEnable(flag) {
                    if (flag == true) { // 펜
                        $('#pen').attr("alt", "pen");
                        $('#pen').attr("srcset", "/image/pencil.svg");
                        enableSketch(true);
                        $('#videosource').css("pointer-events", "none"); // 비디오에 판서 사용시 아웃 터치 안먹게
                    } else { // 터치
                        $('#pen').attr("alt", "touch");
                        $('#pen').attr("srcset", "/image/finger.svg");
                        enableSketch(false);
                        $('#videosource').css("pointer-events", "all");
                    }
                }

                function PrepareVideo(image_url) {
                    xhttp.open('GET', image_url, false);
                    xhttp.send();
                }

                function getDistance(mapoint1, mapoint2) {
                    let lat1 = Math.round(mapoint1.getLat());
                    let lat2 = Math.round(mapoint2.getLat());
                    let lon1 = Math.round(mapoint1.getLng());
                    let lon2 = Math.round(mapoint2.getLng());

                    const R = 6371e3; // metres
                    const φ1 = lat1 * Math.PI / 180; // φ, λ in radians
                    const φ2 = lat2 * Math.PI / 180;
                    const Δφ = (lat2 - lat1) * Math.PI / 180;
                    const Δλ = (lon2 - lon1) * Math.PI / 180;

                    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                        Math.cos(φ1) * Math.cos(φ2) *
                        Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                    const d = R * c; // in metres            

                    return Math.round(d);
                }

                //행정구역 및 카메라 정보
                $.ajax({
                    url: "resources/json/MapInfo.json",
                    dataType: 'json',
                    async: false,
                    success: function(json) {
                        mapInfo = json;
                    }
                });

                //행정구역 구분
                $.getJSON("resources/json/CTPRVN.json", function(geojson) {
                    var data = geojson.features;
                    var coordinates = []; //좌표 저장할 배열
                    var name = ''; //행정 구 이름

                    $.each(data, function(index, val) {

                        coordinates = val.geometry.coordinates;
                        name = val.properties.CTP_KOR_NM;

                        if (val.geometry.type == "Polygon") {
                            displayArea(coordinates, name);
                        } else {
                            for (i = 0; i < coordinates.length; i++) {
                                var object = coordinates[i];
                                displayArea(object, name);
                            }
                        }
                    })
                });

                //카메라 마커 추가
                insertMarker();

                //행정구역 폴리곤
                function displayArea(coordinates, name) {

                    var path = []; //폴리곤 그려줄 path
                    var points = []; //중심좌표 구하기 위한 지역구 좌표들

                    $.each(coordinates[0], function(index, coordinate) { //console.log(coordinates)를 확인해보면 보면 [0]번째에 배열이 주로 저장이 됨.  그래서 [0]번째 배열에서 꺼내줌.
                        var point = new Object();
                        point.x = coordinate[1];
                        point.y = coordinate[0];
                        points.push(point);
                        path.push(new kakao.maps.LatLng(coordinate[1], coordinate[0])); //new daum.maps.LatLng가 없으면 인식을 못해서 path 배열에 추가
                    })

                    // 다각형을 생성합니다 
                    var polygon = new kakao.maps.Polygon({
                        map: map, // 다각형을 표시할 지도 객체
                        path: path,
                        strokeWeight: 3,
                        strokeColor: '#004c80',
                        strokeOpacity: 0.8,
                        fillColor: '#fff',
                        fillOpacity: 0.4,
                    });

                    polygon.name = name;

                    polygons.push(polygon); //폴리곤 제거하기 위한 배열

                    // 다각형에 mouseover 이벤트를 등록하고 이벤트가 발생하면 폴리곤의 채움색을 변경합니다 
                    // 지역명을 표시하는 커스텀오버레이를 지도위에 표시합니다
                    kakao.maps.event.addListener(polygon, 'mouseover', function(mouseEvent) {
                        polygon.setOptions({
                            fillColor: '#09f'
                        });

                    });

                    // 다각형에 mousemove 이벤트를 등록하고 이벤트가 발생하면 커스텀 오버레이의 위치를 변경합니다 
                    kakao.maps.event.addListener(polygon, 'mousemove', function(mouseEvent) {

                    });

                    // 다각형에 mouseout 이벤트를 등록하고 이벤트가 발생하면 폴리곤의 채움색을 원래색으로 변경합니다
                    // 커스텀 오버레이를 지도에서 제거합니다 
                    kakao.maps.event.addListener(polygon, 'mouseout', function() {
                        polygon.setOptions({
                            fillColor: '#fff'
                        });
                    });

                    // 다각형에 click 이벤트를 등록하고 이벤트가 발생하면 해당 지역 확대을 확대합니다.
                    kakao.maps.event.addListener(polygon, 'click', function() {
                        var level = mapInfo[polygon.name].zoomlevel;
                        var center = centroid(points);
                        selectCenter = center;

                        visibleMarker(polygon.name);

                        if (map.getLevel() == level) {
                            map.panTo(selectCenter);
                        } else {
                            // 지도를 클릭된 폴리곤의 중앙 위치를 기준으로 확대합니다
                            map.setLevel(level, {
                                anchor: center,
                                animate: {
                                    duration: 350 //확대 애니메이션 시간
                                }
                            });
                        }

                        polygon.setOptions({
                            fillColor: '#fff'
                        });

                    });
                }

                kakao.maps.event.addListener(map, 'zoom_changed', function() {
                    map.panTo(selectCenter);
                })

                function insertMarker() {
                    for (var sidoName in mapInfo) {
                        markers[sidoName] = [];
                        labels[sidoName] = [];
                        for (var iter in mapInfo[sidoName]['cameraInfo']) {
                            var camera = mapInfo[sidoName]['cameraInfo'][iter];
                            if (camera.visible == false) {
                                continue;
                            }

                            var imageSrc = './image/cctv_icon.png';
                            var imageSize = new kakao.maps.Size(68, 72);
                            var imageOption = {
                                offset: new kakao.maps.Point(0, 36)
                            };

                            var markerImage = new kakao.maps.MarkerImage(imageSrc, imageSize, imageOption);
                            var markerPosition = new kakao.maps.LatLng(camera.lan, camera.lon);

                            var marker = new kakao.maps.Marker({
                                map: map,
                                clickable: true,
                                zIndex: 3,
                                position: markerPosition,
                                image: markerImage // 마커이미지 설정                                                                 
                            });

                            marker.camera = camera;

                            kakao.maps.event.addListener(marker, 'click', makeOverListener(map, marker));

                            marker.setVisible(false);
                            markers[sidoName].push(marker);

                            // ----------------------------------- 커스텀 오버레이 테스트
                            //var content = '<div id="label"><span class="left"></span><span class="center">' + camera.name + '</span><span class="right"></span></div>';
                            var content = '<div id="label"><span class="center"><p id="labeltext">' + camera.name + '</p></span><span class="right"></span></div>';
                            var customOverlay = new kakao.maps.CustomOverlay({
                                map: map,
                                position: markerPosition,
                                content: content,
                                xAnchor: 0,
                                yAnchor: 0.5,
                                zIndex: 2
                            });

                            customOverlay.setVisible(false);
                            customOverlay.setMap(map);
                            labels[sidoName].push(customOverlay);
                            // ------------------------------------ 
                        }
                    }
                }

                function makeOverListener(map, marker) {
                    return function() {
                        var e = window.event;
                        posX = e.clientX;
                        posY = e.clientY;
                        PrepareVideo(marker.camera.url);

                        $("#videosource").css("left", posX);
                        $("#videosource").css("top", posY);
                        $("#videosource").css("display", "initial");
                        $('#videosource').animate({
                            width: videoresolution.width,
                            height: videoresolution.height,
                            left: 0,
                            top: 0
                        }, 'slow');
                    };
                }

                function visibleMarker(sidoName) {
                    for (var sido in markers) {
                        var bVisible = (sido == sidoName);
                        var cameraList = markers[sido];
                        var labelList = labels[sido];

                        for (var iter in cameraList) {
                            cameraList[iter].setVisible(bVisible);
                            labelList[iter].setVisible(bVisible);
                        }
                    }
                }

                //centroid 알고리즘 (폴리곤 중심좌표 구하기 위함)
                function centroid(points) {
                    var i, j, len, p1, p2, f, area, x, y;

                    area = x = y = 0;

                    for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
                        p1 = points[i];
                        p2 = points[j];

                        f = p1.y * p2.x - p2.y * p1.x;
                        x += (p1.x + p2.x) * f;
                        y += (p1.y + p2.y) * f;
                        area += f * 3;
                    }

                    return new kakao.maps.LatLng(x / area, y / area);
                }

                var COLOURS = ['#cc0000']; //['#1900FF'];
                var radius = 0;
                var sketchCanvas = Sketch.create({

                    container: document.getElementById('sketchcontainer'),
                    autoclear: false,
                    retina: 'auto',

                    setup: function() {
                        console.log('setup');
                    },

                    update: function() {
                        radius = 2 + abs(sin(this.millis * 0.003) * 10);
                    },

                    // Event handlers
                    /*
                    keydown: function() {
                        if ( this.keys.C ) this.clear();
                    },
                    */

                    // Mouse & touch events are merged, so handling touch events by default
                    // and powering sketches using the touches array is recommended for easy
                    // scalability. If you only need to handle the mouse / desktop browsers,
                    // use the 0th touch element and you get wider device support for free.
                    touchmove: function() {
                        for (var i = this.touches.length - 1, touch; i >= 0; i--) {

                            touch = this.touches[i];

                            this.lineCap = 'round';
                            this.lineJoin = 'round';
                            this.fillStyle = this.strokeStyle = COLOURS[i % COLOURS.length];
                            this.lineWidth = radius;

                            this.beginPath();
                            this.moveTo(touch.ox, touch.oy);
                            this.lineTo(touch.x, touch.y);
                            this.stroke();
                        }
                    }
                });

                function enableSketch(enable) {
                    if (enable) {
                        $("#sketchcontainer").css("pointer-events", "all");
                    } else {
                        sketchCanvas.clear();
                        $("#sketchcontainer").css("pointer-events", "none");
                    }
                }

                enableSketch(false);

            }) // End ready
    </script>

</head>

<body>
    <div id="map"></div>
    <aside class="toplayer">
        <div class="videolayer">
            <video id='videosource' class="video-js" preload="auto" data-setup='{"fluid": true}'></video>
        </div>
        <div class="menulayer">
            <div id="sketchcontainer"></div>
            <img id="home" src="/image/globe.png" alt="home image" srcset="/image/globe.svg">
            <img id="pen" src="/image/finger.png" alt="touch" srcset="/image/finger.svg">
        </div>
    </aside>
</body>

</html>