<!-- https://github.com/aliencrossroad/TouchMap/ -->
<!DOCTYPE html>
<html>

<head>
    <link href="css/video-js.css" rel="stylesheet" />
    <link href="css/styles.css" rel="stylesheet" />

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>YTN GIS SYSTEM</title>

    <script type="text/javascript" src="js/jquery-3.4.1.min.js"></script>
    <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=d30b430fc168d024cbfef307b239c005&libraries=services"></script>
    <script type="text/javascript" src="js/video.js"></script>

    <script>
        var initmaplevel = 13;
        var centerCoordinate = { // 지도의 중심좌표
            lan: 36.0,
            lon: 127.9259
        };

        var polygons = [];
        var markers = [];
        var selectCenter;
        var mapInfo;

        $(document).ready(function() {

            var mapContainer = document.getElementById('map'), // 지도를 표시할 div 
                mapOption = {
                    center: new kakao.maps.LatLng(centerCoordinate.lan, centerCoordinate.lon), // 지도의 중심좌표
                    level: initmaplevel // 지도의 확대 레벨
                };

            // 지도를 생성합니다    
            var map = new kakao.maps.Map(mapContainer, mapOption);
            var mapTypeControl = new kakao.maps.MapTypeControl();
            map.addControl(mapTypeControl, kakao.maps.ControlPosition.TOPRIGHT);

            $('#home')
                .on('touchstart click', function(e) {
                    e.preventDefault();

                    // 현재 지도의 레벨을 얻어옵니다
                    var level = map.getLevel();

                    selectCenter = mapOption.center;

                    // 지도 레벨이 다르면 레벨 맞춰주고
                    if (level != initmaplevel) {
                        // 지도를 클릭된 폴리곤의 중앙 위치를 기준으로 확대합니다
                        map.setLevel(initmaplevel, {
                            animate: {
                                duration: 350 //확대 애니메이션 시간
                            }
                        });
                    }
                    visibleMarker();
                });

            $("#videosource").css("width", 0);
            $("#videosource").css("height", (window.innerHeight - 8));
            $('#videosource')
                .on('touchstart click', function(e) {
                    e.preventDefault();
                    $('#videosource').animate({
                        width: '0'
                    }, 'slow', function() {
                        $("#videosource").css("display", "none");
                        $("#videosource")[0].player.pause();
                    })
                });

            function PrepareVideo(image_url) {
                var player = videojs('videosource', {
                    "controls": false,
                    "autoplay": false,
                    "preload": "auto",
                    'html5': {
                        'nativeAudioTracks': false
                    }
                }, function onPlayerReady() {
                    this.src({
                        type: "application/x-mpegURL",
                        src: image_url
                    });
                    this.tech_.off('dblclick');
                    this.play();

                });
            }

            function getDistance(mapoint1, mapoint2) {
                let lat1 = Math.round(mapoint1.getLat());
                let lat2 = Math.round(mapoint2.getLat());
                let lon1 = Math.round(mapoint1.getLng());
                let lon2 = Math.round(mapoint2.getLng());

                const R = 6371e3; // metres
                const φ1 = lat1 * Math.PI / 180; // φ, λ in radians
                const φ2 = lat2 * Math.PI / 180;
                const Δφ = (lat2 - lat1) * Math.PI / 180;
                const Δλ = (lon2 - lon1) * Math.PI / 180;

                const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                    Math.cos(φ1) * Math.cos(φ2) *
                    Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                const d = R * c; // in metres            

                return Math.round(d);
            }

            //행정구역 및 카메라 정보
            $.ajax({
                url: "resources/json/MapInfo.json",
                dataType: 'json',
                async: false,
                success: function(json) {
                    mapInfo = json;
                }
            });

            //행정구역 구분
            $.getJSON("resources/json/CTPRVN.json", function(geojson) {
                var data = geojson.features;
                var coordinates = []; //좌표 저장할 배열
                var name = ''; //행정 구 이름

                $.each(data, function(index, val) {

                    coordinates = val.geometry.coordinates;
                    name = val.properties.CTP_KOR_NM;

                    if (val.geometry.type == "Polygon") {
                        displayArea(coordinates, name);
                    } else {
                        for (i = 0; i < coordinates.length; i++) {
                            var object = coordinates[i];
                            displayArea(object, name);
                        }
                    }
                })
            });

            //카메라 마커 추가
            insertMarker();

            //행정구역 폴리곤
            function displayArea(coordinates, name) {

                var path = []; //폴리곤 그려줄 path
                var points = []; //중심좌표 구하기 위한 지역구 좌표들

                $.each(coordinates[0], function(index, coordinate) { //console.log(coordinates)를 확인해보면 보면 [0]번째에 배열이 주로 저장이 됨.  그래서 [0]번째 배열에서 꺼내줌.
                    var point = new Object();
                    point.x = coordinate[1];
                    point.y = coordinate[0];
                    points.push(point);
                    path.push(new kakao.maps.LatLng(coordinate[1], coordinate[0])); //new daum.maps.LatLng가 없으면 인식을 못해서 path 배열에 추가
                })

                // 다각형을 생성합니다 
                var polygon = new kakao.maps.Polygon({
                    map: map, // 다각형을 표시할 지도 객체
                    path: path,
                    strokeWeight: 3,
                    strokeColor: '#004c80',
                    strokeOpacity: 0.8,
                    fillColor: '#fff',
                    fillOpacity: 0.4,
                });

                polygon.name = name;

                polygons.push(polygon); //폴리곤 제거하기 위한 배열

                // 다각형에 mouseover 이벤트를 등록하고 이벤트가 발생하면 폴리곤의 채움색을 변경합니다 
                // 지역명을 표시하는 커스텀오버레이를 지도위에 표시합니다
                kakao.maps.event.addListener(polygon, 'mouseover', function(mouseEvent) {
                    polygon.setOptions({
                        fillColor: '#09f'
                    });

                });

                // 다각형에 mousemove 이벤트를 등록하고 이벤트가 발생하면 커스텀 오버레이의 위치를 변경합니다 
                kakao.maps.event.addListener(polygon, 'mousemove', function(mouseEvent) {

                });

                // 다각형에 mouseout 이벤트를 등록하고 이벤트가 발생하면 폴리곤의 채움색을 원래색으로 변경합니다
                // 커스텀 오버레이를 지도에서 제거합니다 
                kakao.maps.event.addListener(polygon, 'mouseout', function() {
                    polygon.setOptions({
                        fillColor: '#fff'
                    });
                });

                // 다각형에 click 이벤트를 등록하고 이벤트가 발생하면 해당 지역 확대을 확대합니다.
                kakao.maps.event.addListener(polygon, 'click', function() {
                    var level = mapInfo[polygon.name].zoomlevel;
                    var center = centroid(points);
                    selectCenter = center;

                    visibleMarker(polygon.name);

                    if (map.getLevel() == level) {
                        map.panTo(selectCenter);
                    } else {
                        // 지도를 클릭된 폴리곤의 중앙 위치를 기준으로 확대합니다
                        map.setLevel(level, {
                            anchor: center,
                            animate: {
                                duration: 350 //확대 애니메이션 시간
                            }
                        });
                    }

                    polygon.setOptions({
                        fillColor: '#fff'
                    });

                });
            }

            kakao.maps.event.addListener(map, 'zoom_changed', function() {
                map.panTo(selectCenter);
            })

            function insertMarker() {
                for (var sidoName in mapInfo) {
                    markers[sidoName] = [];
                    for (var iter in mapInfo[sidoName]['cameraInfo']) {
                        var camera = mapInfo[sidoName]['cameraInfo'][iter];

                        var imageSrc = './image/camera_68.png';
                        var imageSize = new kakao.maps.Size(64, 64);
                        var imageOption = {
                            offset: new kakao.maps.Point(27, 69)
                        };

                        var markerImage = new kakao.maps.MarkerImage(imageSrc, imageSize, imageOption);
                        var markerPosition = new kakao.maps.LatLng(camera.lan, camera.lon);

                        var marker = new kakao.maps.Marker({
                            map: map,
                            position: markerPosition,
                            image: markerImage // 마커이미지 설정 
                        });

                        marker.camera = camera;

                        kakao.maps.event.addListener(marker, 'click', makeOverListener(map, marker));

                        marker.setVisible(false);
                        markers[sidoName].push(marker);
                    }
                }
            }

            function makeOverListener(map, marker) {
                return function() {
                    PrepareVideo(marker.camera.url);
                    $("#videosource").css("height", (window.innerHeight - 8));
                    $("#videosource").css("display", "initial");
                    $('#videosource').animate({
                        width: (window.innerWidth - 20)
                    }, 'slow');
                };
            }

            function visibleMarker(sidoName) {
                for (var sido in markers) {
                    var bVisible = (sido == sidoName);
                    var cameraList = markers[sido];

                    for (var iter in cameraList) {
                        cameraList[iter].setVisible(bVisible);
                    }
                }
            }

            function Home() {
                selectCenter = new kakao.maps.LatLng(centerCoordinate.x, centerCoordinate.y);
                map.setLevel(
                    initmaplevel, {
                        anchor: selectCenter,
                        animate: {
                            duration: 350 //확대 애니메이션 시간
                        }
                    }
                );

                visibleMarker();
            }

            //centroid 알고리즘 (폴리곤 중심좌표 구하기 위함)
            function centroid(points) {
                var i, j, len, p1, p2, f, area, x, y;

                area = x = y = 0;

                for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
                    p1 = points[i];
                    p2 = points[j];

                    f = p1.y * p2.x - p2.y * p1.x;
                    x += (p1.x + p2.x) * f;
                    y += (p1.y + p2.y) * f;
                    area += f * 3;
                }
                return new kakao.maps.LatLng(x / area, y / area);
            }
        }) // End ready
    </script>

</head>

<body>
    <div id="map"></div>
    <aside class="videolayer">
        <video id='videosource' class="video-js" preload="auto" data-setup="{}"></video>
        <img id="home" src="/image/map.png" alt="home image" srcset="/image/map.svg">
    </aside>
</body>

</html>